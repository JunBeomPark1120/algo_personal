# N명의 병사가 무작위로 나열되어 있음.
# 각 병사는 특정한 값의 전투력을 보유하고 있음.

# 병사를 배치할 땐 전투력이 높은 병사가 앞쪽에 오도록
# 내림차순 배치를 하고자 함.
# 결론 : 앞쪽에 있는 병사의 전투력이 항상 뒤쪽에 있는 병사보다
# 높아야 함.

# 또한 배치 과정에선 특정한 위치에 있는 병사를 열외시키는 방법을 이용
# 그러면서도 남아 있는 병사의 수가 최대가 되도록 하고 싶음.

# N = 7, 나열된 병사들의 전투력이 다음과 같다고 가정
# 병사 번호 : | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
# 전투력    : |15 |11 | 4 | 8 | 5 | 2 | 4 |

# 이 때, 3번 6번 병사를 열외 시키면, 다음과 같이 남아 있는 병사의 수가
# 내림차순의 형태가 되며, 5명이 됨.
# 이는 남아 있는 병사의 수가 최대가 되도록 하는 방법
# 병사 번호 : | 1 | 2 | 4 | 5 | 7 |
# 전투력    : |15 |11 | 8 | 5 | 4 |

# 병사에 대한 정보가 주어졌을 때, 남아있는 병사의 수가 최대가 되도록
# 하기 위해 열외시켜야 하는 병사의 수를 출력하는 프로그램을 작성

# 가장 긴 증가하는 부분 수열(LIS) 알고리즘을 확인해 보자
# D[i] = array[i]를 마지막 원소로 가지는 부분 수열의 최대 길이
# 점화식은 다음과 같음
# 모든 0 <= j and j < i에 대해, D[i] = max(D[i], D[j] + 1)
# if array[j] < array[i]

#                   |  4  |  2  |  5  |  8  |  4  |  11  |  15  |
# 초기 상태 i = 0    |  1  |  1  |  1  |  1  |  1  |  1   |  1  |
#          i = 1    |  1  |  1  |  1  |  1  |  1  |  1   |  1  |
#          i = 2    |  1  |  1  |  2  |  1  |  1  |  1   |  1  |
#          i = 3    |  1  |  1  |  2  |  3  |  1  |  1   |  1  |
#          i = 4    |  1  |  1  |  2  |  3  |  2  |  1   |  1  |
#          i = 5    |  1  |  1  |  2  |  3  |  2  |  4   |  1  |
#          i = 6    |  1  |  1  |  2  |  3  |  2  |  4   |  5  |

# 가장 먼저 입력 받은 병사 정보의 순서를 뒤집음
# 가장 긴 증가하는 부분 수열(LIS) 알고리즘을 수행하여 정답을 도출함.

n = int(input())
array = list(map(int, input().split()))

# 순서를 뒤집어 '최장 증가 부분 수열' 문제로 변환
array.reverse()

# 다이나믹 프로그래밍을 위한 1차원 DP 테이블 초기화
dp = [1] * n

# 가장 긴 증가하는 부분 수열(LIS) 알고리즘 수행
for i in range(1, n):
    for j in range(0, i):
        if array[j] < array[i]:
            dp[i] = max(dp[i], dp[j] + 1)
            
# 열외해야 하는 병사의 최소 수를 출력
print(n - max(dp))